/*
 * This file implements the CPU instructions, based on
 */

//! # Decoding and exection of opcodes.
//! Implementation based on the [GB Docs PDF](https://gekkio.fi/files/gb-docs/gbctr.pdf)
//!
//! ## Durations
//! Each instuction at least takes 1 m_cycle due to fetching the opcode from memory via `[PC++]`.
//! Reading immediate values also takes 1 additional m_cycle per value due to fetching memory via `[PC++]`.

use crate::{
    cpu::{
        instructions::LoadTarget,
        memory::{Address, Immediate8, Reg16, Reg8},
    },
    GameBoy, Hardware,
};

impl GameBoy {
    pub fn execute_unprefixed(&mut self, opcode: u8) {
        use Reg16::*;
        use Reg8::*;

        #[rustfmt::skip]
        match opcode {
            // --- 8-bit operations
            // 8-bit loads
            0x7F => self.load(A, A),
            0x78 => self.load(A, B),
            0x79 => self.load(A, C),
            0x7A => self.load(A, D),
            0x7B => self.load(A, E),
            0x7C => self.load(A, H),
            0x7D => self.load(A, L),
            0x7E => self.load(A, Address::HL),
            0x47 => self.load(B, A),
            0x40 => self.load(B, B),
            0x41 => self.load(B, C),
            0x42 => self.load(B, D),
            0x43 => self.load(B, E),
            0x44 => self.load(B, H),
            0x45 => self.load(B, L),
            0x46 => self.load(B, Address::HL),
            0x4F => self.load(C, A),
            0x48 => self.load(C, B),
            0x49 => self.load(C, C),
            0x4A => self.load(C, D),
            0x4B => self.load(C, E),
            0x4C => self.load(C, H),
            0x4D => self.load(C, L),
            0x4E => self.load(C, Address::HL),
            0x57 => self.load(D, A),
            0x50 => self.load(D, B),
            0x51 => self.load(D, C),
            0x52 => self.load(D, D),
            0x53 => self.load(D, E),
            0x54 => self.load(D, H),
            0x55 => self.load(D, L),
            0x56 => self.load(D, Address::HL),
            0x5F => self.load(E, A),
            0x58 => self.load(E, B),
            0x59 => self.load(E, C),
            0x5A => self.load(E, D),
            0x5B => self.load(E, E),
            0x5C => self.load(E, H),
            0x5D => self.load(E, L),
            0x5E => self.load(E, Address::HL),
            0x67 => self.load(H, A),
            0x60 => self.load(H, B),
            0x61 => self.load(H, C),
            0x62 => self.load(H, D),
            0x63 => self.load(H, E),
            0x64 => self.load(H, H),
            0x65 => self.load(H, L),
            0x66 => self.load(H, Address::HL),
            0x6F => self.load(L, A),
            0x68 => self.load(L, B),
            0x69 => self.load(L, C),
            0x6A => self.load(L, D),
            0x6B => self.load(L, E),
            0x6C => self.load(L, H),
            0x6D => self.load(L, L),
            0x6E => self.load(L, Address::HL),
            0x3E => self.load(A, Immediate8),
            0x06 => self.load(B, Immediate8),
            0x0E => self.load(C, Immediate8),
            0x16 => self.load(D, Immediate8),
            0x1E => self.load(E, Immediate8),
            0x26 => self.load(H, Immediate8),
            0x2E => self.load(L, Immediate8),
            0x36 => self.load(Address::HL, Immediate8),
            0x77 => self.load(Address::HL, A),
            0x70 => self.load(Address::HL, B),
            0x71 => self.load(Address::HL, C),
            0x72 => self.load(Address::HL, D),
            0x73 => self.load(Address::HL, E),
            0x74 => self.load(Address::HL, H),
            0x75 => self.load(Address::HL, L),
            0x0A => self.load(A, Address::BC),
            0x02 => self.load(Address::BC, A),
            0x1A => self.load(A, Address::DE),
            0x12 => self.load(Address::DE, A),
            0xFA => self.load(A, Address::Immediate),
            0xEA => self.load(Address::Immediate, A),
            0x3A => self.load(A, Address::HLD),
            0x32 => self.load(Address::HLD, A),
            0x2A => self.load(A, Address::HLI),
            0x22 => self.load(Address::HLI, A),
            0xF2 => self.load(A, Address::ZeroPageC),
            0xE2 => self.load(Address::ZeroPageC, A),
            0xF0 => self.load(A, Address::ZeroPage),
            0xE0 => self.load(Address::ZeroPage, A),
            // // 8-bit arithmetic
            // 0x87 => self.add(A),
            // 0x80 => self.add(B),
            // 0x81 => self.add(C),
            // 0x82 => self.add(D),
            // 0x83 => self.add(E),
            // 0x84 => self.add(H),
            // 0x85 => self.add(L),
            // 0x86 => self.add(Address::HL),
            // 0xC6 => self.add(Immediate8),
            // 0x8F => self.adc(A),
            // 0x88 => self.adc(B),
            // 0x89 => self.adc(C),
            // 0x8A => self.adc(D),
            // 0x8B => self.adc(E),
            // 0x8C => self.adc(H),
            // 0x8D => self.adc(L),
            // 0x8E => self.adc(Address::HL),
            // 0xCE => self.adc(Immediate8),
            // 0x97 => self.sub(A),
            // 0x90 => self.sub(B),
            // 0x91 => self.sub(C),
            // 0x92 => self.sub(D),
            // 0x93 => self.sub(E),
            // 0x94 => self.sub(H),
            // 0x95 => self.sub(L),
            // 0x96 => self.sub(Address::HL),
            // 0xD6 => self.sub(Immediate8),
            // 0x9F => self.sbc(A),
            // 0x98 => self.sbc(B),
            // 0x99 => self.sbc(C),
            // 0x9A => self.sbc(D),
            // 0x9B => self.sbc(E),
            // 0x9C => self.sbc(H),
            // 0x9D => self.sbc(L),
            // 0x9E => self.sbc(Address::HL),
            // 0xDE => self.sbc(Immediate8),
            // 0xBF => self.cp(A),
            // 0xB8 => self.cp(B),
            // 0xB9 => self.cp(C),
            // 0xBA => self.cp(D),
            // 0xBB => self.cp(E),
            // 0xBC => self.cp(H),
            // 0xBD => self.cp(L),
            // 0xBE => self.cp(Address::HL),
            // 0xFE => self.cp(Immediate8),
            // 0xA7 => self.and(A),
            // 0xA0 => self.and(B),
            // 0xA1 => self.and(C),
            // 0xA2 => self.and(D),
            // 0xA3 => self.and(E),
            // 0xA4 => self.and(H),
            // 0xA5 => self.and(L),
            // 0xA6 => self.and(Address::HL),
            // 0xE6 => self.and(Immediate8),
            // 0xB7 => self.or(A),
            // 0xB0 => self.or(B),
            // 0xB1 => self.or(C),
            // 0xB2 => self.or(D),
            // 0xB3 => self.or(E),
            // 0xB4 => self.or(H),
            // 0xB5 => self.or(L),
            // 0xB6 => self.or(Address::HL),
            // 0xF6 => self.or(Immediate8),
            // 0xAF => self.xor(A),
            // 0xA8 => self.xor(B),
            // 0xA9 => self.xor(C),
            // 0xAA => self.xor(D),
            // 0xAB => self.xor(E),
            // 0xAC => self.xor(H),
            // 0xAD => self.xor(L),
            // 0xAE => self.xor(Address::HL),
            // 0xEE => self.xor(Immediate8),
            // 0x3C => self.inc(A),
            // 0x04 => self.inc(B),
            // 0x0C => self.inc(C),
            // 0x14 => self.inc(D),
            // 0x1C => self.inc(E),
            // 0x24 => self.inc(H),
            // 0x2C => self.inc(L),
            // 0x34 => self.inc(Address::HL),
            // 0x3D => self.dec(A),
            // 0x05 => self.dec(B),
            // 0x0D => self.dec(C),
            // 0x15 => self.dec(D),
            // 0x1D => self.dec(E),
            // 0x25 => self.dec(H),
            // 0x2D => self.dec(L),
            // 0x35 => self.dec(Address::HL),
            // 0x07 => self.rlca(ctx),
            // 0x17 => self.rla(ctx),
            // 0x0F => self.rrca(ctx),
            // 0x1F => self.rra(ctx),
            // // --- Control
            // 0xC3 => self.jp(ctx),
            // 0xE9 => self.jp_hl(ctx),
            // 0x18 => self.jr(ctx),
            // 0xCD => self.call(ctx),
            // 0xC9 => self.ret(ctx),
            // 0xD9 => self.reti(ctx),
            // 0xC2 => self.jp_cc(Cond::NZ),
            // 0xCA => self.jp_cc(Cond::Z),
            // 0xD2 => self.jp_cc(Cond::NC),
            // 0xDA => self.jp_cc(Cond::C),
            // 0x20 => self.jr_cc(Cond::NZ),
            // 0x28 => self.jr_cc(Cond::Z),
            // 0x30 => self.jr_cc(Cond::NC),
            // 0x38 => self.jr_cc(Cond::C),
            // 0xC4 => self.call_cc(Cond::NZ),
            // 0xCC => self.call_cc(Cond::Z),
            // 0xD4 => self.call_cc(Cond::NC),
            // 0xDC => self.call_cc(Cond::C),
            // 0xC0 => self.ret_cc(Cond::NZ),
            // 0xC8 => self.ret_cc(Cond::Z),
            // 0xD0 => self.ret_cc(Cond::NC),
            // 0xD8 => self.ret_cc(Cond::C),
            // 0xC7 => self.rst(0x00),
            // 0xCF => self.rst(0x08),
            // 0xD7 => self.rst(0x10),
            // 0xDF => self.rst(0x18),
            // 0xE7 => self.rst(0x20),
            // 0xEF => self.rst(0x28),
            // 0xF7 => self.rst(0x30),
            // 0xFF => self.rst(0x38),
            // // --- Miscellaneous
            // 0x76 => self.halt(ctx),
            // 0x10 => self.stop(ctx),
            // 0xF3 => self.di(ctx),
            // 0xFB => self.ei(ctx),
            // 0x3F => self.ccf(ctx),
            // 0x37 => self.scf(ctx),
            // 0x00 => self.nop(ctx),
            // 0x27 => self.daa(ctx),
            // 0x2F => self.cpl(ctx),
            // // --- 16-bit operations
            // // 16-bit loads
            0x01 => self.load16_imm(BC),
            0x11 => self.load16_imm(DE),
            0x21 => self.load16_imm(HL),
            0x31 => self.load16_imm(SP),
            // 0x08 => self.load16_nn_sp(ctx),
            // 0xF9 => self.load16_sp_hl(ctx),
            // 0xF8 => self.load16_hl_sp_e(ctx),
            // 0xC5 => self.push16(BC),
            // 0xD5 => self.push16(DE),
            // 0xE5 => self.push16(HL),
            // 0xF5 => self.push16(AF),
            // 0xC1 => self.pop16(BC),
            // 0xD1 => self.pop16(DE),
            // 0xE1 => self.pop16(HL),
            // 0xF1 => self.pop16(AF),
            // // 16-bit arithmetic
            // 0x09 => self.add16(BC),
            // 0x19 => self.add16(DE),
            // 0x29 => self.add16(HL),
            // 0x39 => self.add16(SP),
            // 0xE8 => self.add16_sp_e(ctx),
            // 0x03 => self.inc16(BC),
            // 0x13 => self.inc16(DE),
            // 0x23 => self.inc16(HL),
            // 0x33 => self.inc16(SP),
            // 0x0B => self.dec16(BC),
            // 0x1B => self.dec16(DE),
            // 0x2B => self.dec16(HL),
            // 0x3B => self.dec16(SP),
            // 0xCB => self.cb_prefix(ctx),
            // 0xD3 | 0xDB | 0xDD | 0xE3 | 0xE4 | 0xEB | 0xEC | 0xED | 0xF4 | 0xFC | 0xFD => {
            //     self.undefined(ctx)
            // }

            _ => todo!("Implement unprefixed opcode 0x{opcode:X}")
        }
    }

    pub fn execute_cb_prefixed(&mut self, opcode: u8) {
        todo!("EXECUTE UNPREFIXED 0x{opcode:X}")
    }
}
